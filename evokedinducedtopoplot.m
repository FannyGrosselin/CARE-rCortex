% evokedinducedtopoplot() - function which plots a topographic map of a 
%                           scalp data field in a 2-D circular view (looking
%                           down at the top of the head) using interpolation  
%                           on a fine cartesian grid. Nose is at top of plot; 
%                           left is left; right is right. There are interactive
%                           channels on the scalp. When you have chosen channel(s),
%                           press "Display" button : time-frequency maps
%                           appear like with timefrequencyevoked(), 
%                           timefrequencyinduced(), timefrequencyevokedBase() 
%                           or timefrequencyinducedBase(). The used algorithm 
%                           depends on the input "algo".   
%                           This function is inspired by topoplot.m.
%
% Author: Fanny Grosselin, 2018
%                       
% Usage:
%   >> evokedinducedtopoplot(Values,loc_file,trueEEGchanlocslabels,range_colorbar,EEGtimes,freqvector,EEGsrate,resulparamclbk,Z,M,unit,tit, aux_plot,significant_line,baseline,marker_baseline, latpos, listauxbase, len_base, minb, maxb, correction_baseline, signif_level, algo,varargin)
%

% Required Inputs:
%   Values   -   [array] write [].
%   loc_file -   [structure array] structure array of channel location 
%                you want to see on the scalp - see EEG.chanlocs.
%   trueEEGchanlocslabels - [array] array of channel labels you want to see
%                on the scalp - see 'labels' field in EEG.chanlocs.
%   range_colorbar - ['automatic' or array of integer] Write 'automatic' if
%              you want colorbar spreads between minimum value of time-frequency
%              map and maximum value of time-frequency map. Otherwise,
%              write an array of integer like this : [colorbar_min colorbar_max].
%   EEGtimes -   [array of double] It's the same as EEG.times.
%   freqvector - [raw vector of integer] vector of frequency
%                [lower frequency:resolution:higher frequency]
%                WARNING : you have to enter frequencies in normalized
%                units (frequency in Hz divided by sampling frequency (EEG.srate)).
%   EEGsrate -   [integer] It's the same as EEG.srate.
%   resulparamclbk - [structure of integers] :
%                resulparamclbk(1).valparam = lower frequency
%                resulparamclbk(2).valparam = higher frequency
%                resulparamclbk(3).valparam = frequency resolution
%                WARNING : divide your integers (in Hz) by sampling frequency
%                (EEG.srate).
%   Z - [array] array of time-frequency map values. See
%                timefrequencyevoked(), timefrequencyinduced(),
%                timefrequencyevokedBase() or timefrequencyinducedBase().
%   M - [array] array of time-frequency map values that are significant, relatively
%                to the chosen baseline. See timefrequencyevokedBase() 
%                or timefrequencyinducedBase().
%   unit - [column vector] column vector of char which contains units of the
%                channels you want to see on the scalp.
%   tit - [char] char containing title of time-frequency map, specifing algorithm, 
%                without name of channel. You have to write :
%                'Time frequency evoked map on channel' or 
%                'Time frequency induced map on channel'or 
%                'Time frequency evoked map (corrected with baseline) on channel' or
%                'Time frequency induced map (corrected with baseline) on channel'.
%   aux_plot - [integer] 0 if you don't want to display, under the
%              time-frequency map, a plot of mean of channel epochs with baseline
%              location. Else, the channel number you want to plot the
%              mean through epochs. 
%   significant_line - [char] 'yes' : display significant line
%               'no' : don't display significant line.
%   baseline - [char] Write 'yes' to specify you want to analyse with
%              a baseline algorithm. Else, write 'no'.
%   marker_baseline - [char] Write :
%               - 'Start of inspiration' if you want to choose baseline
%                 according to the start of inspiration. 
%            or - 'Start of exhalation' if you want to choose baseline
%                 according to the start of exhalation.
%            or - 'Maximum of flow/pressure' if you want to choose baseline
%                 according to the maximum of flow or pressure signal.
%            or - 'Minimum of flow/pressure' if you want to choose baseline
%                 according to the minimum of flow or pressure signal.
%   latpos [char] 'positive' : locate the baseline on the right of markers
%               which are described above. 'negative' : locate the baseline
%               on the left of markers which are descirbed above. 
%   listauxbase [char] 'pressure' : choose the baseline according to the
%               pressure signal. 'flow' : choose the baseline according to
%               the flow signal.
%   len_base [char] Write the baseline length in ms.
%   minb - [integer or 'NaN'] Write the point corresponding to the baseline start. 
%          It must be between EEG.xmin*1000 and EEG.xmax*1000. If there is
%          no baseline, write 'NaN'.
%   maxb - [integer or 'NaN'] Write the point corresponding to the baseline end. 
%          It must be between EEG.xmin*1000 and EEG.xmax*1000. If there is
%          no baseline, write 'NaN'.
%   correction_baseline - [string] "z-score"|"absolute"|"relative"|"dB"
%			  "z-score" means that the mean value of baseline is substracted 
%			   from data and the standard deviation of baseline is divided
%			  "absolute" means that the mean value of baseline is subtracted
%			   from data
%		      "relative" means the data is a percentage of the mean value of baseline.
%			  "dB" means the data is divided by the mean value of baseline and then 
%			       transfomed in decibel (10*log10 operation).
%   signif_level - [value] Significance level to compute two-tailed
%           permutation significance probability level. This allows to
%           show significant points of the time-frequency map based on
%           this threshold. This will only work with the time-frequency computation
%           "Plot induced potentials (average of time-frequency
%           maps)". It will compute the significant mask based on baseline 
%           permutation, described in Grandchamp and Delorme, Frontiers in 
%           Pyscology (Sept 2011). Here we used 500 baseline permutations for 
%           each frequency bin. 
%           The surrogate time-frequency map with randome baseline is compared 
%           to the time-frequency map, normalized with a z-score baseline 
%           correction.
%           The obtained mask can be multiplied on the original
%           time-frequency map normalized by the chosen type baseline. 
%   algo - [char] You have to chose one of these four sentences :
%              'Evoked activities',
%              'Induced activities',
%              'Evoked activities (corrected with baseline)',
%              'Induced activities (corrected with baseline)'.
%
% Optional input : 
%       'chaninfo' - enter information channels (EEG.chaninfo)
%
% Output from pop-up:
%   Plot a topographic map of a scalp data field in a 2-D circular view (looking
%   down at the top of the head) with interactive channels. When you press 
%   "Display" button : time-frequency maps appear like with timefrequencyevoked(), 
%   timefrequencyinduced(), timefrequencyevokedBase() or timefrequencyinducedBase().
%   The function also saves a structure called savedata_matrix which
%   contains the figure handle, the datafile name, the markerfile name, the
%   headerfile name, the type of event, the sampling rate, the number of epochs, 
%   the lower frequency in the map, the higher frequency in the map,
%   the frequency resolution in the map, if the user have chosen baseline or not.
%	If a baseline is chosen, the function saves the type of the baseline correction 
%	(Z-score, absolute, relative, dB) and if it's an automatic or a
%   manual baseline. If a significance level is chosen, it will save this value.
%   If it's an automatic baseline, the function saves the channel
%   number used for choosing baseline, the marker of the baseline start, the sign of
%   baseline latency, the baseline length. If it's a manual baseline, the function 
%   saves the baseline start (in ms) and the baseline end (in ms). It also saves 
%   the channel(s) that the user want to compute, the name of algorithm chosen and if 
%   the user want to display significant line or not. WARNING : the figure handle
%   indicates the location of these information in the structure (examples
%   : the information of figure number 2 are saved in savedata_matrix(1,2);
%   the information of figure number 10 are saved in savedata_matrix(1,10)).
%
% See also:
%   pop_evokedinduced(), waveletTransformFourierPAD(), timefrequencyevoked(), 
%   timefrequencyinduced(), timefrequencyevokedBase(), timefrequencyinducedBase(), 
%   evokedinduced_save(), plotaux(), fcn_savedata().

function evokedinducedtopoplot(Values,loc_file,trueEEGchanlocslabels,range_colorbar,EEGtimes,freqvector,EEGsrate,resulparamclbk,Z,M,unit,tit, aux_plot,significant_line,baseline,marker_baseline, latpos, listauxbase, len_base, minb, maxb, correction_baseline,signif_level, algo,varargin)

%%%%%%%%%%%%%%%%%%%%%%%% Set defaults %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
icadefs % read defaults MAXTOPOPLOTCHANS and DEFAULT_ELOC and BACKCOLOR
BACKCOLOR = [.93 .96 1];  % EEGLAB standard

persistent warningInterp;

setappdata(0,'EEGtimes',EEGtimes);
setappdata(0,'freqvector',freqvector);
setappdata(0,'EEGsrate',EEGsrate);
setappdata(0,'resulparamclbk',resulparamclbk);
setappdata(0,'trueEEGchanlocslabels',trueEEGchanlocslabels);
setappdata(0,'range_colorbar',range_colorbar);
setappdata(0,'trueEEGchanlocs',loc_file);
setappdata(0,'Z',Z);
setappdata(0,'M',M);
setappdata(0,'unit',unit);
setappdata(0,'tit',tit);
setappdata(0,'aux_plot',aux_plot);
setappdata(0,'significant_line',significant_line);
setappdata(0,'baseline',baseline);
setappdata(0,'marker_baseline',marker_baseline);
setappdata(0,'latpos',latpos);
setappdata(0,'listauxbase',listauxbase);
setappdata(0,'len_base',len_base);
setappdata(0,'minb',minb);
setappdata(0,'maxb',maxb);
setappdata(0,'correction_baseline',correction_baseline);
setappdata(0,'signif_level',signif_level);
setappdata(0,'algo',algo);

rmax = 0.5;             % actual head radius - Don't change this!
CIRCGRID   = 201;       % number of angles to use in drawing circles
AXHEADFAC = 1.3;        % head to axes scaling factor
HEADCOLOR = [0 0 0];    % default head color (black)
EMARKERLINEWIDTH = 1;   % default edge linewidth for emarkers
ECOLOR = [0 0 0];       % default electrode color = black
EFSIZE = get(0,'DefaultAxesFontSize'); % use current default fontsize for electrode labels
HLINEWIDTH = 2;         % default linewidth for head, nose, ears
shrinkfactor = [];      % shrink mode (dprecated)
plotrad      = [];      % plotting radius ([] = auto, based on outermost channel location)
headrad      = [];      % default plotting radius for cartoon head is 0.5
CHOOSECHANTYPE = 0;
COLORARRAY  = { [1 0 0] [0.5 0 0] [0 0 0] };

%%%%%% Dipole defaults %%%%%%%%%%%%
NOSEDIR   = '+X';
CHANINFO  = [];

%%%%%%%%%%%%%%%%%%%%%%% Handle arguments %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if nargin< 1
    help topoplot;
    return
end

nargs = nargin;
if nargs == 1
    if isstr(Values)
        if any(strcmp(lower(Values),{'example','demo'}))
            fprintf(['This is an example of an electrode location file,\n',...
                'an ascii file consisting of the following four columns:\n',...
                ' channel_number degrees arc_length channel_name\n\n',...
                'Example:\n',...
                ' 1               -18    .352       Fp1 \n',...
                ' 2                18    .352       Fp2 \n',...
                ' 5               -90    .181       C3  \n',...
                ' 6                90    .181       C4  \n',...
                ' 7               -90    .500       A1  \n',...
                ' 8                90    .500       A2  \n',...
                ' 9              -142    .231       P3  \n',...
                '10               142    .231       P4  \n',...
                '11                 0    .181       Fz  \n',...
                '12                 0    0          Cz  \n',...
                '13               180    .181       Pz  \n\n',...
                ...
                'In topoplot() coordinates, 0 deg. points to the nose, positive\n',...
                'angles point to the right hemisphere, and negative to the left.\n',...
                'The model head sphere has a circumference of 2; the vertex\n',...
                '(Cz) has arc_length 0. Locations with arc_length > 0.5 are below\n',...
                'head center and are plotted outside the head cartoon.\n',...
                'Option plotrad controls how much of this lower-head "skirt" is shown.\n',...
                'Option headrad controls if and where the cartoon head will be drawn.\n',...
                'Option intrad controls how many channels will be included in the interpolation.\n',...
                ])
            return
        end
    end
end

if nargs < 2
    loc_file = DEFAULT_ELOC;
    if ~exist(loc_file)
        fprintf('default locations file "%s" not found - specify chan_locs in topoplot() call.\n',loc_file)
        error(' ')
    end
end
if isempty(loc_file)
    loc_file = 0;
end
if isnumeric(loc_file) & loc_file == 0
    loc_file = DEFAULT_ELOC;
end

if nargs > 2
    Param = varargin{1};
    Value = varargin{2};
    if ~isstr(Param)
        error('Flag arguments must be strings')
    end
    if Param == 'chaninfo'
        CHANINFO = Value;
        if isfield(CHANINFO, 'nosedir'), NOSEDIR      = CHANINFO.nosedir; end;
        if isfield(CHANINFO, 'shrink' ), shrinkfactor = CHANINFO.shrink;  end;
        if isfield(CHANINFO, 'plotrad') & isempty(plotrad), plotrad = CHANINFO.plotrad; end;
        if isfield(CHANINFO, 'chantype')
            chantype = CHANINFO.chantype;
            if ischar(chantype), chantype = cellstr(chantype); end
            CHOOSECHANTYPE = 1;
        end
    else
        error(['Unknown input parameter ''' Param ''' ???'])
    end
end
cmap = colormap;
cmaplen = size(cmap,1);

ContourVals = zeros(1,length(loc_file));
ContourVals(Values) = 1;
Values = ContourVals;

%%%%%%%%%%%%%%%%%%%%%%%%%%% misc arg tests %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
[r,c] = size(Values);
if r>1 & c>1,
    error('input data must be a single vector');
end
Values = Values(:); % make Values a column vector
ContourVals = ContourVals(:); % values for contour

%%%%%%%%%%%%%%%%%%%% Read the channel location information %%%%%%%%%%%%%%%%%%%%%%%%
if isstr(loc_file)
    [tmpeloc labels Th Rd indices] = readlocs( loc_file);
elseif isstruct(loc_file) % a locs struct
    [tmpeloc labels Th Rd indices] = readlocs( loc_file );
    % Note: Th and Rd correspond to indices channels-with-coordinates only
else
    error('loc_file must be a EEG.locs struct or locs filename');
end
Th = pi/180*Th;                              % convert degrees to radians
allchansind = 1:length(Th);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% channels to plot %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
plotchans = indices;

%%%%%%%%%%%%%%%%%%% last channel is reference? %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if length(tmpeloc) == length(Values) + 1 % remove last channel if necessary
    % (common reference channel)
    if plotchans(end) == length(tmpeloc)
        plotchans(end) = [];
    end; 
end;

%%%%%%%%%%%%%%%%%%% remove infinite and NaN values %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if length(Values) > 1
    inds          = union_bc(find(isnan(Values)), find(isinf(Values))); % NaN and Inf values
    plotchans     = setdiff_bc(plotchans, inds);
end;

if length(labels) ~= length(plotchans)
    cv = 0;
    v = [];
    for iu = 1 : length(labels)
        u =find(ismember(labels(plotchans),labels(iu)));
        if isempty(u)
            cv = cv + 1;
            v = sprintf('%s %s',v,char(labels(iu)));
        end;
    end;
    errordlg2(sprintf('%s %s %s','WARNING :', v ,'have empty location... These channels will not be printed on the head.'),'Warning');
    if cv == length(labels)
        close(gcf);
        return;
    end;
end;

[x,y]     = pol2cart(Th,Rd);  % transform electrode locations from polar to cartesian coordinates
plotchans = abs(plotchans);   % reverse indicated channel polarities
allchansind = allchansind(plotchans);
Th        = Th(plotchans);
Rd        = Rd(plotchans);
x         = x(plotchans);
y         = y(plotchans);
labels    = labels(plotchans); % remove labels for electrodes without locations
labels    = strvcat(labels); % make a label string matrix
if ~isempty(Values) & length(Values) > 1
    Values      = Values(plotchans);
    ContourVals = ContourVals(plotchans);
end;

%%%%%%%%%%%%%%%%%% Read plotting radius from chanlocs  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if isempty(plotrad) & isfield(tmpeloc, 'plotrad'),
    plotrad = tmpeloc(1).plotrad;
    if isstr(plotrad)                        % plotrad shouldn't be a string
        plotrad = str2num(plotrad)           % just checking
    end
    if plotrad < 0.15| plotrad > 1.0
        fprintf('Bad value (%g) for plotrad.\n',plotrad);
        error(' ');
    end
end;
if isempty(plotrad)
    plotrad = min(1.0,max(Rd)*1.02);            % default: just outside the outermost electrode location
    plotrad = max(plotrad,0.5);                 % default: plot out to the 0.5 head boundary
end                                           % don't plot channels with Rd > 1 (below head)
default_intrad = 1;     % indicator for (no) specified intrad
intrad = min(1.0,max(Rd)*1.02);             % default: just outside the outermost electrode location
if isstr(plotrad) | plotrad < 0.15| plotrad > 1.0
    error('plotrad must be between 0.15 and 1.0');
end

%%%%%%%%%%%%%%%%%%%%%%% Set radius of head cartoon %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if plotrad >= rmax
    headrad = rmax;  % (anatomically correct)
else % if plotrad < rmax
    headrad = 0;    % don't plot head
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Shrink mode %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if ~isempty(shrinkfactor) | isfield(tmpeloc, 'shrink'),
    if isempty(shrinkfactor) & isfield(tmpeloc, 'shrink'),
        shrinkfactor = tmpeloc(1).shrink;
    end;
    if isstr(shrinkfactor)
        if strcmpi(shrinkfactor, 'on') | strcmpi(shrinkfactor, 'force') | strcmpi(shrinkfactor, 'auto')
            if abs(headrad-rmax) > 1e-2
                fprintf('     NOTE -> the head cartoon will NOT accurately indicate the actual electrode locations\n');
            end
            headrad = plotrad; % plot head around outer electrodes, no matter if 0.5 or not
        end
    else % apply shrinkfactor
        plotrad = rmax/(1-shrinkfactor);
        headrad = plotrad;  % make deprecated 'shrink' mode plot
    end
end; % if shrink

%%%%%%%%%%%%%%%%%%%%% Find plotting channels  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pltchans = find(Rd <= plotrad); % plot channels inside plotting circle
% interpolate channels in the radius intrad square
intchans = find(x <= intrad & y <= intrad); % interpolate and plot channels inside interpolation square

%%%%%%%%%%%%%%%%%%%%% Eliminate channels not plotted  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
allx      = x;
ally      = y;
intchans; % interpolate using only the 'intchans' channels
pltchans; % plot using only indicated 'plotchans' channels

if ~isempty(Values)
    if length(Values) == length(Th)  % if as many map Values as channel locs
        intValues      = Values(intchans);
        intContourVals = ContourVals(intchans);
        Values         = Values(pltchans);
        ContourVals    = ContourVals(pltchans);
    end;
end;   % now channel parameters and values all refer to plotting channels only

allchansind = allchansind(pltchans);
intTh = Th(intchans);           % eliminate channels outside the interpolation area
intRd = Rd(intchans);
intx  = x(intchans);
inty  = y(intchans);
Th    = Th(pltchans);              % eliminate channels outside the plotting area
Rd    = Rd(pltchans);
x     = x(pltchans);
y     = y(pltchans);
labels= labels(pltchans,:);

%%%%%%%%%%%%%%% Squeeze channel locations to <= rmax %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
squeezefac = rmax/plotrad;
intRd = intRd*squeezefac; % squeeze electrode arc_lengths towards the vertex
Rd = Rd*squeezefac;       % squeeze electrode arc_lengths towards the vertex
% to plot all inside the head cartoon
intx = intx*squeezefac;
inty = inty*squeezefac;
x    = x*squeezefac;
y    = y*squeezefac;
allx    = allx*squeezefac;
ally    = ally*squeezefac;
% Note: Now outermost channel will be plotted just inside rmax

%%%%%%%%%%%%%%%% rotate channels based on chaninfo %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if strcmpi(lower(NOSEDIR), '+x')
    rotate = 0;
else
    if strcmpi(lower(NOSEDIR), '+y')
        rotate = 3*pi/2;
    elseif strcmpi(lower(NOSEDIR), '-x')
        rotate = pi;
    else rotate = pi/2;
    end;
    allcoords = (inty + intx*sqrt(-1))*exp(sqrt(-1)*rotate);
    intx = imag(allcoords);
    inty = real(allcoords);
    allcoords = (ally + allx*sqrt(-1))*exp(sqrt(-1)*rotate);
    allx = imag(allcoords);
    ally = real(allcoords);
    allcoords = (y + x*sqrt(-1))*exp(sqrt(-1)*rotate);
    x = imag(allcoords);
    y = real(allcoords);
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Make the plot %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% Draw blank head %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
hold on
set(gca,'Xlim',[-rmax rmax]*AXHEADFAC,'Ylim',[-rmax rmax]*AXHEADFAC)
tl = title('Click on channel(s) you want to study');
set(tl, 'fontweight', 'bold');

%%%%%%%%%%%%%%%%%%% Plot filled ring to mask jagged grid boundary %%%%%%%%%%%%%%%%%%%%%%%%%%%
hwidth = .007;                   % width of head ring
hin  = squeezefac*headrad*(1- hwidth/2);  % inner head ring radius
rwidth = .035;         % width of blanking outer ring
rin    =  rmax*(1-rwidth/2);              % inner ring radius
if hin>rin
    rin = hin;                              % dont blank inside the head ring
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% mask the jagged border around rmax %%%%%%%%%%%%%%%5%%%%%%
circ = linspace(0,2*pi,CIRCGRID);
rx = sin(circ);
ry = cos(circ);
ringx = [[rx(:)' rx(1) ]*(rin+rwidth)  [rx(:)' rx(1)]*rin];
ringy = [[ry(:)' ry(1) ]*(rin+rwidth)  [ry(:)' ry(1)]*rin];

%%%%%%%%%%%%%%%%%%%%%%%%% Plot cartoon head, ears, nose %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if headrad > 0                         % if cartoon head to be plotted
    %%%%%%%%%%%%%%%%%%% Plot head outline %%%%%%%%%%%%%%%%%%%%%%%%%%%
    headx = [[rx(:)' rx(1) ]*(hin+hwidth)  [rx(:)' rx(1)]*hin];
    heady = [[ry(:)' ry(1) ]*(hin+hwidth)  [ry(:)' ry(1)]*hin];
    
    if ~isstr(HEADCOLOR) | ~strcmpi(HEADCOLOR,'none')
       %ringh= patch(headx,heady,ones(size(headx)),HEADCOLOR,'edgecolor',HEADCOLOR,'linewidth', HLINEWIDTH); hold on
       headx = [rx(:)' rx(1)]*hin;
       heady = [ry(:)' ry(1)]*hin;
       ringh= plot(headx,heady);
       set(ringh, 'color',HEADCOLOR,'linewidth', HLINEWIDTH); hold on
    end
    %%%%%%%%%%%%%%%%%%% Plot ears and nose %%%%%%%%%%%%%%%%%%%%%%%%%%%
    base  = rmax-.0046;
    basex = 0.18*rmax;                   % nose width
    tip   = 1.15*rmax;
    tiphw = .04*rmax;                    % nose tip half width
    tipr  = .01*rmax;                    % nose tip rounding
    q = .04; % ear lengthening
    EarX  = [.497-.005  .510  .518  .5299 .5419  .54    .547   .532   .510   .489-.005]; % rmax = 0.5
    EarY  = [q+.0555 q+.0775 q+.0783 q+.0746 q+.0555 -.0055 -.0932 -.1313 -.1384 -.1199];
    sf    = headrad/plotrad;                                          % squeeze the model ears and nose by this factor
    if ~isstr(HEADCOLOR) | ~strcmpi(HEADCOLOR,'none')
        plot3([basex;tiphw;0;-tiphw;-basex]*sf,[base;tip-tipr;tip;tip-tipr;base]*sf,...
            2*ones(size([basex;tiphw;0;-tiphw;-basex])),...
            'Color',HEADCOLOR,'LineWidth',HLINEWIDTH);                 % plot nose
        plot3(EarX*sf,EarY*sf,2*ones(size(EarX)),'color',HEADCOLOR,'LineWidth',HLINEWIDTH)    % plot left ear
        plot3(-EarX*sf,EarY*sf,2*ones(size(EarY)),'color',HEADCOLOR,'LineWidth',HLINEWIDTH)   % plot right ear
    end
end

% %%%%%%%%%%%%%%%%%%% Show electrode information %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
plotax = gca;
axis square                                           % make plotax square
axis off

pos = get(gca,'position');
xlm = get(gca,'xlim');
ylm = get(gca,'ylim');
% textax = axes('position',pos,'xlim',xlm,'ylim',ylm);  % make new axes so clicking numbers <-> labels
% will work inside head cartoon patch
% axes(textax);
axis square                                           % make textax square

pos = get(gca,'position');
set(plotax,'position',pos);

xlm = get(gca,'xlim');
set(plotax,'xlim',xlm);

ylm = get(gca,'ylim');
set(plotax,'ylim',ylm);                               % copy position and axis limits again

axis equal;
set(gca, 'xlim', [-0.525 0.525]); set(plotax, 'xlim', [-0.525 0.525]);
set(gca, 'ylim', [-0.525 0.525]); set(plotax, 'ylim', [-0.525 0.525]);

EMARKERSIZE = 10;
if length(y)>=160
    EMARKERSIZE = 3;
elseif length(y)>=128
    EMARKERSIZE = 3;
elseif length(y)>=100
    EMARKERSIZE = 3;
elseif length(y)>=80
    EMARKERSIZE = 4;
elseif length(y)>=64
    EMARKERSIZE = 5;
elseif length(y)>=48
    EMARKERSIZE = 6;
elseif length(y)>=32
    EMARKERSIZE = 8;
end

%%%%%%%%%%%%%%%%%%%%%%%% Mark electrode locations only %%%%%%%%%%%%%%%%%%%%%%%%%%
ELECTRODE_HEIGHT = 2.1;  % z value for plotting electrode information (above the surf)

%%%%%%%%%%%%%%%%%%%%%%%% Mark electrode locations plus labels %%%%%%%%%%%%%%%%%%%

hp2 = plot3(y,x,ones(size(x))*ELECTRODE_HEIGHT,...
    '.','Color',ECOLOR,'markersize',EMARKERSIZE,'linewidth',EMARKERLINEWIDTH);

channelselected = [];
setappdata(0, 'channelselected', channelselected);

for i = 1:size(labels,1)
    hh(i) = text(double(y(i)+0.01),double(x(i)),...
        ELECTRODE_HEIGHT,labels(i,:),'HorizontalAlignment','left',...
        'VerticalAlignment','middle','Color',ECOLOR,'userdata', labels(i,:), ...
        'FontSize',EFSIZE, 'buttondownfcn', ...
        [...
        'ECOLOR = get(gco,''color'');'...
        'if ECOLOR == [0 0 0]'...
            '    set(gco,''color'',[0.4 1 0.7]);'...
            '    tmpstr = get(gco, ''userdata'');'...
            '    set(gco, ''userdata'', get(gco, ''string''));' ...
            '    set(gco, ''string'', tmpstr);'...
            '    channelselected = [getappdata(0,''channelselected''); tmpstr];'...
            '    setappdata(0, ''channelselected'', channelselected);'...
            '    clear tmpstr;'...
        'else'...
            '    set(gco,''color'',[0 0 0]);'...
            '    tmpstr = get(gco, ''userdata'');'...
            '    set(gco, ''userdata'', get(gco, ''string''));' ...
            '    set(gco, ''string'', tmpstr);'...
            ...
            '    [L, C] = size(channelselected);'...
            '    i = 1;'...
            '    while i <= L'...
                '    if tmpstr == channelselected(i,:)'...
                    '    channelselected(i,:) = [];'...
                    '    setappdata(0, ''channelselected'', channelselected);'...
                    '    i = L+1;'...
                '    else'...
                    '    i = i+1;'...
                '    end;'...
            '    end;'...
            '    clear tmpstr i;'...
        'end;']);
end

%%%%%%%%%%%%%%%%% Buttons : display and cancel %%%%%%%%%%%%%%%
displayclbk = [...
    'EEGtimes = getappdata(0,''EEGtimes'');'...
    'freqvector = getappdata(0,''freqvector'');'...
    'EEGsrate = getappdata(0,''EEGsrate'');'...
    'resulparamclbk = getappdata(0,''resulparamclbk'');'...
    'trueEEGchanlocslabels = getappdata(0,''trueEEGchanlocslabels'');'...
    'range_colorbar = getappdata(0,''range_colorbar'');'...
    'trueEEGchanlocs = getappdata(0,''trueEEGchanlocs'');'...
    'EEGchaninfo = getappdata(0,''EEGchaninfo'');'...
    'Z = getappdata(0,''Z'');'...
	'M = getappdata(0,''M'');'...
    'unit = getappdata(0,''unit'');'...
    'tit = getappdata(0,''tit'');'...
    'baseline = getappdata(0,''baseline'');'...
    'marker_baseline = getappdata(0,''marker_baseline'');'...
    'latpos = getappdata(0,''latpos'');'...
    'listauxbase = getappdata(0,''listauxbase'');'...
    'len_base = getappdata(0,''len_base'');'...
    'minb = getappdata(0,''minb'');'...
    'maxb = getappdata(0,''maxb'');'...
	'correction_baseline = getappdata(0,''correction_baseline'');'...
    'signif_level = getappdata(0,''signif_level'');'...
    'algo = getappdata(0,''algo'');'...
    'aux_plot = getappdata(0,''aux_plot'');'...
    'significant_line = getappdata(0,''significant_line'');'...
    ...
    'indice = find(ismember(trueEEGchanlocslabels,channelselected));'...
    'setappdata(0,''indice'',indice);'...
    ...
    'EEG = evalin(''base'',''EEG'');'... 
    'if aux_plot ~= 0'...
        '    auxi_plot = EEG.chanlocs(aux_plot).labels;'...
    'else'...
        '    auxi_plot = ''none'';'...
    'end;'...
	'nbEpoch = 100;'... % number or epochs chosen for the calculation of the TF maps and the epoch averaging --> to be faster
	'if EEG.trials<100'...
		'    epochChosen = [1:EEG.trials];'...
		'    fprintf(''All the %s trials are chosen for the computation of the time-frequency map(s).\n'',num2str(EEG.trials));'...
	'else'...
		'    epochChosen = [1:floor(EEG.trials/nbEpoch):EEG.trials];'... % chose about 100 epochs by a regular way in order to don't have time bias
		'    fprintf(''%s over %s trials are chosen for the computation of the time-frequency map(s).\n'',num2str(length(epochChosen)),num2str(EEG.trials));'...
	'end;'...
    'for k = 1:length(indice)'...
        '    setappdata(0,''k'',k);'...
        '    if strcmp(auxi_plot,''none'')'...
            '    set(0,''Units'',''points'');'...
            '    scrsz = get(0,''ScreenSize'');'...
            '    fig = figure(''Position'',[1 1 scrsz(3)/4 1.2*scrsz(4)/2]);'...
            '    set(0,''Units'',''normalized'');'...
            '    scrsz = get(0,''ScreenSize'');'...
            '    h0 = axes(''Position'',[scrsz(3)/5, scrsz(4)/8, scrsz(3)/1.3, scrsz(4)/1.4]);'...
            '    set(gcf,''Color'',[0.95,0.98,1]);'...
            '    myimage = imagesc(EEGtimes, freqvector*EEGsrate, Z{1,indice(k)});'...
			'    m=100;'...
			'    cm_plasma=plasma(m);'...
			'    colormap(h0,plasma);'...
			'    if signif_level ~= 0'...
				'    Xmyimage = get(myimage,''XData'');'...
				'    Ymyimage = get(myimage,''YData'');'...
				'    I = (M{1,indice(k)}<1);'...
				... % Make a truecolor all-gray image.
				'    greenI = cat(3, 0.5*ones(size(M{1,indice(k)})), 0.5*ones(size(M{1,indice(k)})), 0.5*ones(size(M{1,indice(k)})));'...
				'    hold on;'...
				'    hh = imagesc(greenI);'...
				'    set(hh,''XData'',Xmyimage);'...
				'    set(hh,''YData'',Ymyimage);'...
				... % Use our influence map image as the AlphaData for the solid gray image.
				'   set(hh, ''AlphaData'', 0.8*I);'...
			'    end;'...
            '    axis(''xy'');'...
            '    title(sprintf(''%s %s'',tit,char(trueEEGchanlocslabels(indice(k)))),''edgecolor'',''red'',''linewidth'',1);'...
            '    xlabel(''Time (ms)'');'...
            '    ylabel(''Frequency (Hz)'');'...
            '    if ~isnan(Z{1,indice(k)})'...
                '    if isstr(range_colorbar)'...
                    '    caxis([min(min(Z{1,indice(k)})) max(max(Z{1,indice(k)}))]);'...
                '    else'...
                    '    caxis([range_colorbar(1) range_colorbar(2)]);'...
                '    end;'...
                '    c = colorbar;'...
                '    title(c, unit(indice(k),:));'...
            '    elseif isnan(Z{1,indice(k)})'...
                '    errordlg2(sprintf(''WARNING : The %s signal is null or empty !'',char(trueEEGchanlocslabels(indice(k)))),''Warning'');'...
            '    else'...
                '    Y = Z{1,indice(k)};'...
                '    Y(isnan(Y)) = [];'...
                '    if isstr(range_colorbar)'...
                    '    caxis([min(min(Y)) max(max(Y))]);'...
                '    else'...
                    '    caxis([range_colorbar(1) range_colorbar(2)]);'...
                '    end;'...
                '    c = colorbar;'...
                '    title(c, unit(indice(k),:));'...
            '    end;'...
            ... % Plot signficant line
            ... % --------------------
            '    if strcmp(significant_line,''yes'') '...
                '    ko = 5;'...  % for Morlet Wavelet
                '    fourier_factor = (4*pi)/(ko + sqrt(2+ko^2));'...
                '    coi = fourier_factor/sqrt(2);'...
                '    n1 = size(Z{1,indice(k)},2);'...
                '    coi = coi*1*[1E-5,1:((n1+1)/2-1),fliplr((1:(n1/2-1))),1E-5];'...
                '    upCurve = EEGsrate./coi;'...
                '    lowCurve = -0.5.*ones(size(coi));'...
                ... % Overlay the cone of influence
                '    hold on;'...
                '    [ph,msg]=jbfill(EEGtimes,lowCurve,upCurve,[0.2 0.2 0.2],[0 0 0],1,0.7);'...
                '    hold off;'...
            '    end;'...
            ... % Plot line on image
            ... % ------------------
            '    hold on;'...
            '    p1 = [0,0];'...
            '    p2 = [min(ylim),max(ylim)];'...
            '    plot([p1(1),p1(2)],[p2(1),p2(2)],''w--'');'...
            '    hold off;'...
            ... % Plot scalp
            ... % ----------
            '    axes(''Position'',[0, 3.8*(scrsz(4)/5), scrsz(3)/6, scrsz(4)/6]);'...
            '    topoplot(indice(k),trueEEGchanlocs(indice(k)),''electrodes'',''on'',''style'', ''blank'',''emarker'',{''.'',''r'',20,1},''noplot'',''off'',''chaninfo'',EEGchaninfo);'...
            '    title(char(trueEEGchanlocslabels(indice(k))),''color'',''red'');'...
            ...% Allow save data
            ... % ---------------
            ... % recovery of data matrix
            '    try'...
                '    savedata_matrix = getappdata(0,''savedata_matrix'');'...
            '    end;'...
            '    if isempty(savedata_matrix)'...
                '    savedata_matrix = struct(''figure'',[],''datafile'',[],''markerfile'',[],''headerfile'',[],''markerstimulus'',[],''samplingrate'',[],''epochnumber'',[],''lowfreq'',[],''highfreq'',[],''resolfreq'',[],''baseline'',[],''minb'',[],''maxb'',[],''correction_baseline'',[],''signif_level'',[],''channelchosenforbaseline'',[],''beginningbaseline'',[],''latencysign'',[],''baselinelength'',[],''channelplot'',[],''algorithm'',[],''significantline'',[]);'...
            '    end;'...
            ... % recovery of some data
            '    p = EEG.filepath;'...
            '    [linecomments colcomments] = size(EEG.comments);'...
            '    for s = 1:linecomments'...
				'    if strcmp(''Original file: '',EEG.comments(s,1:15));'...
					'    datafile = deblank(EEG.comments(s,16:end));'...
					'    markerfile = [datafile(1:end-3),''vmrk''];'...
					'    headerfile = [datafile(1:end-3),''vhdr''];'...
				'    elseif strcmp(''Parent dataset: '',EEG.comments(s,1:16));'...
					'    datafile = deblank(EEG.comments(s,17:end));'...
					'    markerfile = [];'...
					'    headerfile = [];'...
				'    end;'...
			'    end;'...
            ... % recording of data in a structure 
            '    savedata.figure = fig.Number;'...
            '    savedata.datafile = char(datafile);'...
            '    savedata.markerfile = char(markerfile);'...
            '    savedata.headerfile = char(headerfile);'...
            '    savedata.markerstimulus = char(EEG.event(1,2).type);'...
            '    savedata.samplingrate = EEGsrate;'...
            '    savedata.epochnumber = EEG.trials;'...
            '    savedata.lowfreq = resulparamclbk(1).valparam * EEGsrate;'...
            '    savedata.highfreq = resulparamclbk(2).valparam * EEGsrate;'...
            '    savedata.resolfreq = resulparamclbk(3).valparam * EEGsrate;'...
            '    savedata.baseline = baseline;'...
            '    if strcmp(minb,''NaN'') && strcmp(maxb,''NaN'')'...
                '    savedata.minb = minb;'...
                '    savedata.maxb = maxb;'...
            '    else'...
                '    if strcmp(baseline,''manual'')'...
                    '    savedata.minb = num2str(minb(1));'...
                    '    savedata.maxb = num2str(maxb(1));'...
                '    elseif strcmp(baseline,''automatic'')'...
                    '    savedata.minb = '' '';'...
                    '    savedata.maxb = '' '';'...
                '    end;'...
            '    end;'...
			'    savedata.correction_baseline = correction_baseline;'...
            '    savedata.signif_level = signif_level;'...
            '    savedata.channelchosenforbaseline = listauxbase;'...
            '    savedata.beginningbaseline = marker_baseline;'...
            '    savedata.latencysign = latpos;'...
            '    savedata.baselinelength = len_base;'...
            '    savedata.channelplot = char(trueEEGchanlocslabels(indice(k)));'...
            '    savedata.algorithm = algo;'...
            '    savedata.significantline = significant_line;'...
            ... % recording structure in the data matrix
            '    savedata_matrix(1,fig.Number) = savedata;'...
            '    setappdata(0,''savedata_matrix'',savedata_matrix);'...
            ... % Save button
            ... % -----------
            '    uicontrol(''style'',''pushbutton'',''string'', ''Save data & figure'',''backgroundcolor'',[0 1 0.5],''units'',''normalized'',''position'', [4*scrsz(3)/5, scrsz(4)/70, scrsz(3)/6, scrsz(4)/15],''fontweight'', ''bold'',''callback'',''fcn_savedata;'');'...
        '    else'...
            ... % MAP PLOT
            ... % --------
            '    set(0,''Units'',''points'');'...
            '    scrsz = get(0,''ScreenSize'');'...
            '    fig = figure(''Position'',[1 1 scrsz(3)/4 scrsz(4)]);'... 
            '    set(0,''Units'',''normalized'');'...
            '    scrsz = get(0,''ScreenSize'');'...
            '    if strcmp(algo,''Evoked activities (corrected with baseline)'')'...
                '    h1 = subplot(3,1,1);'...
            '    else'...
                '    h1 = subplot(2,1,1);'...
            '    end;'...
            '    myimage = imagesc(EEGtimes, freqvector*EEGsrate, Z{1,indice(k)});'...
			'    m=100;'...
			'    cm_plasma=plasma(m);'...
			'    colormap(h1,plasma);'...
			'    if signif_level ~= 0'...
				'    Xmyimage = get(myimage,''XData'');'...
				'    Ymyimage = get(myimage,''YData'');'...
				'    I = (M{1,indice(k)}<1);'...
				... % Make a truecolor all-gray image.
				'    greenI = cat(3, 0.5*ones(size(M{1,indice(k)})), 0.5*ones(size(M{1,indice(k)})), 0.5*ones(size(M{1,indice(k)})));'...
				'    hold on;'...
				'    hh = imagesc(greenI);'...
				'    set(hh,''XData'',Xmyimage);'...
				'    set(hh,''YData'',Ymyimage);'...
				... % Use our influence map image as the AlphaData for the solid gray image.
				'   set(hh, ''AlphaData'', 0.8*I);'...
			'    end;'...
            '    axis(''xy'');'...
            '    title(sprintf(''%s %s'',tit,char(trueEEGchanlocslabels(indice(k)))),''edgecolor'',''red'',''linewidth'',1);'...
            '    xlabel(''Time (ms)'');'...
            '    ylabel(''Frequency (Hz)'');'...
            '    if ~isnan(Z{1,indice(k)})'...
                '    if isstr(range_colorbar)'...
                    '    caxis([min(min(Z{1,indice(k)})) max(max(Z{1,indice(k)}))]);'...
                '    else'...
                    '    caxis([range_colorbar(1) range_colorbar(2)]);'...
                '    end;'...
                '    c = colorbar;'...
                '    title(c, unit(indice(k),:));'...
            '    elseif isnan(Z{1,indice(k)})'...
                '    errordlg2(sprintf(''WARNING : The %s signal is null or empty !'',char(trueEEGchanlocslabels(indice(k)))),''Warning'');'...
            '    else'...
                '    Y = Z{1,indice(k)};'...
                '    Y(isnan(Y)) = [];'...
                '    if isstr(range_colorbar)'...
                    '    caxis([min(min(Y)) max(max(Y))]);'...
                '    else'...
                    '    caxis([range_colorbar(1) range_colorbar(2)]);'...
                '    end;'...
                '    c = colorbar;'...
                '    title(c, unit(indice(k),:));'...
            '    end;'...
            ... % Plot signficant line
            ... % --------------------
            '    if strcmp(significant_line,''yes'') '...
                '    ko = 5;'...  % for Morlet Wavelet
                '    fourier_factor = (4*pi)/(ko + sqrt(2+ko^2));'...
                '    coi = fourier_factor/sqrt(2);'...
                '    n1 = size(Z{1,indice(k)},2);'...
                '    coi = coi*1*[1E-5,1:((n1+1)/2-1),fliplr((1:(n1/2-1))),1E-5];'...
                '    upCurve = EEGsrate./coi;'...
                '    lowCurve = -0.5.*ones(size(coi));'...
                ... % Overlay the cone of influence
                '    hold on;'...
                '    [ph,msg]=jbfill(EEGtimes,lowCurve,upCurve,[0.2 0.2 0.2],[0 0 0],1,0.7);'...
                '    hold off;'...
            '    end;'...
            ... % Plot line on image
            ... % ------------------
            '    hold on;'...
            '    p1 = [0,0];'...
            '    p2 = [min(ylim),max(ylim)];'...
            '    plot([p1(1),p1(2)],[p2(1),p2(2)],''w--'');'...
            '    hold off;'...
            ...
            '    if strcmp(algo,''Evoked activities (corrected with baseline)'')'...
                ... % AVERAGE OF SIGNAL CHOSEN
                ... % ------------------------
                '    subplot(3,1,2);'...
                '    EEGchanlocslabels = [];'...
                '    for ji = 1:EEG.nbchan'...
                    '    EEGchanlocslabels = [EEGchanlocslabels, {EEG.chanlocs(ji).labels}];'...
                '    end;'...
                '    clear ji;'...
                '    A = sum(EEG.data(find(ismember(EEGchanlocslabels,trueEEGchanlocslabels(indice(k)))),:,epochChosen)- mean(EEG.data(find(ismember(EEGchanlocslabels,trueEEGchanlocslabels(indice(k)))),:,epochChosen)),3);'...
                '    clear EEGchanlocslabels;'...
                '    A = A./length(epochChosen);'...
                ... % --------------------------------------
                ... % Load units
                ... % --------------------------------------
                '    p = EEG.filepath;'...
                '    [linecomments colcomments] = size(EEG.comments);'...
                '    for s = 1:linecomments'...
                    '    unit1 = {};'...
                    '    if strcmp(''Original file: '',EEG.comments(s,1:15));'...
                        '    o = deblank(EEG.comments(s,16:end));'...
                        '    n = [o(1:end-3),''vhdr''];'...
                        '    try'...
                            '    hdrunit = readbvconf(p,n);'...
                            '    if isfield(hdrunit,''channelinfos'')'...
                                '    [a,b,c,u] = strread(hdrunit.channelinfos{1,indice(k)},''%s%s%s%s'',1,''delimiter'','','');'...
                            '    else'...
                                '   u = ''\muV'';'...
                            '    end;'...
                            '    v = unicode2native(char(u));'...
                            '    if length(v) == 3'... % if it is microvolts
                                '    unit1 = ''\muV'';'...
                            '    else'...
                                '   unit1 = u;'...
                            '    end;'...
                        '    catch'...
                            '    unit1 = ''\muV'';'...
                        '    end;'...
                    '    else'...
                        '    unit1 = ''\muV'';'...
                    '    end;'...
                '    end;'...
                '    plot(EEG.times,A);'...
                '    axis(''xy'');'... % inversion of direction y
                '    xlabel(''Times (ms)'');'...
                '    ylabel(sprintf(''%s %s'',''Intensity ('',char(unit1),'')''));'...
                '    title(sprintf(''Graph of %s (average based on %s trials)'',char(trueEEGchanlocslabels(indice(k))),num2str(length(epochChosen))));'...
                '    c = colorbar;'...
                '    set(c,''visible'',''off'');'...
                '    hold on;'...
                ... % Plot baseline on image
                ... % ----------------------
                '    baseline_len = (maxb(1) - minb(1));'...
                '    baseline_centre = minb + baseline_len/2;'...
                '    baseline_centre = round(median(baseline_centre));'...
                '    ix = [round(baseline_centre - baseline_len/2) round(baseline_centre - baseline_len/2) round(baseline_centre + baseline_len/2) round(baseline_centre + baseline_len/2)];'...
                '    igrec = [min(ylim) max(ylim) max(ylim) min(ylim)];'...
                '    zed = [0 0 0 0];'...
                '    patch(ix,igrec,zed,''y'');'...
                '    alpha(0.5);'...
                ... % Plot line on image
                ... % ------------------
                ... % define points (in matrix coordinates)
                '    p1 = [0,0];'...
                '    p2 = [min(ylim),max(ylim)];'...
                ... % plot the line
                '    plot([p1(1),p1(2)],[p2(1),p2(2)],''k--'');'...
                '    hold off;'...
            '    end;'...
            ...
            ... % PLOT SCALP
            ... % ----------
            '    set(0,''Units'',''normalized'');'...
            '    scrsz = get(0,''ScreenSize'');'...
            '    axes(''Position'',[scrsz(3)/1.2, scrsz(4)/2.3, scrsz(3)/8, scrsz(4)/8]);'...
            '    topoplot(indice(k),trueEEGchanlocs(indice(k)),''electrodes'',''on'',''style'', ''blank'',''emarker'',{''.'',''r'',20,1},''noplot'',''off'',''chaninfo'',EEGchaninfo);'...
            '    title(char(trueEEGchanlocslabels(indice(k))),''color'',''red'');'...
            ...
			... % AUXILIARY PLOT
            ... % --------------
            '    if ~strcmp(minb,''NaN'') && ~strcmp(maxb,''NaN'')'...
                '    if strcmp(algo,''Evoked activities (corrected with baseline)'')'...
                    '    subplot(3,1,3);'...
                '    else'...
                    '    subplot(2,1,2);'...
                '    end;'...
                '    plotaux(EEG,auxi_plot,minb,maxb,nbEpoch);'...
            '    end;'...
            ...
            ... % ALLOW SAVE DATA
            ... % ---------------
            ... % recovery of data matrix
            '    try'...
                '    savedata_matrix = getappdata(0,''savedata_matrix'');'...
            '    end;'...
            '    if isempty(savedata_matrix)'...
                '    savedata_matrix = struct(''figure'',[],''datafile'',[],''markerfile'',[],''headerfile'',[],''markerstimulus'',[],''samplingrate'',[],''epochnumber'',[],''lowfreq'',[],''highfreq'',[],''resolfreq'',[],''baseline'',[],''minb'',[],''maxb'',[],''correction_baseline'',[],''signif_level'',[],''channelchosenforbaseline'',[],''beginningbaseline'',[],''latencysign'',[],''baselinelength'',[],''channelplot'',[],''algorithm'',[],''significantline'',[]);'...
            '    end;'...
            ... % recovery of some data
            '    p = EEG.filepath;'...
            '    [linecomments colcomments] = size(EEG.comments);'...
            '    for s = 1:linecomments'...
				'    if strcmp(''Original file: '',EEG.comments(s,1:15));'...
					'    datafile = deblank(EEG.comments(s,16:end));'...
					'    markerfile = [datafile(1:end-3),''vmrk''];'...
					'    headerfile = [datafile(1:end-3),''vhdr''];'...
				'    elseif strcmp(''Parent dataset: '',EEG.comments(s,1:16));'...
					'    datafile = deblank(EEG.comments(s,17:end));'...
					'    markerfile = [];'...
					'    headerfile = [];'...
				'    end;'...
			'    end;'...
            ... % recording of data in a structure 
            '    savedata.figure = fig.Number;'...
            '    savedata.datafile = char(datafile);'...
            '    savedata.markerfile = char(markerfile);'...
            '    savedata.headerfile = char(headerfile);'...
            '    savedata.markerstimulus = char(EEG.event(1,2).type);'...
            '    savedata.samplingrate = EEGsrate;'...
            '    savedata.epochnumber = EEG.trials;'...
            '    savedata.lowfreq = resulparamclbk(1).valparam * EEGsrate;'...
            '    savedata.highfreq = resulparamclbk(2).valparam * EEGsrate;'...
            '    savedata.resolfreq = resulparamclbk(3).valparam * EEGsrate;'...
            '    savedata.baseline = baseline;'...
            '    if strcmp(minb,''NaN'') && strcmp(maxb,''NaN'')'...
                '    savedata.minb = minb;'...
                '    savedata.maxb = maxb;'...
            '    else'...
                '    if strcmp(baseline,''manual'')'...
                    '    savedata.minb = num2str(minb(1));'...
                    '    savedata.maxb = num2str(maxb(1));'...
                '    elseif strcmp(baseline,''automatic'')'...
                    '    savedata.minb = '' '';'...
                    '    savedata.maxb = '' '';'...
                '    end;'...
            '    end;'...
			'    savedata.correction_baseline = correction_baseline;'...
            '    savedata.signif_level = signif_level;'...
            '    savedata.channelchosenforbaseline = listauxbase;'...
            '    savedata.beginningbaseline = marker_baseline;'...
            '    savedata.latencysign = latpos;'...
            '    savedata.baselinelength = len_base;'...
            '    savedata.channelplot = char(trueEEGchanlocslabels(indice(k)));'...
            '    savedata.algorithm = algo;'...
            '    savedata.significantline = significant_line;'...
            ... % recording structure in the data matrix
            '    savedata_matrix(1,fig.Number) = savedata;'...
            '    setappdata(0,''savedata_matrix'',savedata_matrix);'...
            ... % Save button
            ... % -----------
            '    uicontrol(''style'',''pushbutton'',''string'', ''Save data & figure'',''backgroundcolor'',[0 1 0.5],''units'',''normalized'',''position'', [4*scrsz(3)/5, scrsz(4)/70, scrsz(3)/6, scrsz(4)/25],''fontweight'', ''bold'',''callback'',''fcn_savedata;'');'...
        '    end;'...
    'end;'...
    'close(gcbf);'...
    'clear  correction_baseline signif_level auxi_plot algo baseline datafile headerfile latpos len linecomments colcomments listauxbase marker_baseline markerfile savedata fig ans len_base c Z Y minb maxb indice_chan L C k p s p1 p2 range_colorbar trueEEGchanlocs EEGchaninfo aux_plot scrsz significant_line tit trueEEGchanlocslabels EEGtimes freqvector EEGsrate resulparamclbk indice channelselected ECOLOR unit ph msg n1 ko fourier_factor coi upCurve lowCurve;'];

cancelclbk = ['close(gcbf);'...
    'clear Z ECOLOR;'];

hold on;
di = uicontrol('style','pushbutton',...
    'units','normalized',...
    'position', [0.7 0.05 0.2 0.07 ],...
    'string','Display',...
    'fontweight','bold','callback',displayclbk);

ca = uicontrol('style','pushbutton',...
    'units','normalized',...
    'position', [0.1 0.05 0.2 0.07],...
    'string','Cancel','callback',cancelclbk);

%%%%%%%%%%%%% Set EEGLAB background color to match head border %%%%%%%%%%%%%%%%%%%%%%%%
try,
    icadefs;
    set(gcf, 'color', BACKCOLOR);
catch,
end;

hold off
axis off

return;
